## 验证机制

对多个阶段的验证功能，尝试按不同顺序发起请求、也可尝试省略一些阶段。开启想象力！

### 用户注册功能

-   用户名枚举
-   非唯一性用户名：用不同的密码两次注册同一个用户名
-   非唯一性用户名：用相同的密码两次注册同一个用户名
    -   报错：可能存在密码爆破，用密码本注册目标账户，可能会有某个密码导致错误那就是现有密码了。
    -   不报错：登录上去修改一些用户数据瞧瞧。
-   `admin`和`admin[空格]`
-   上面两种情况的密码修改功能

### 弱密码 / 默认密码

-   爆破
-   收集
-   万能密码（SQLi）

### 登录失败和成功的不同

-   用户名枚举
-   拦截修改响应绕过登录

### 忘记密码功能

-   条件允许的话完整走一遍忘记密码功能
-   安全问题简单：比如生日，且能通过其他简单途径得到
-   爆破质询答案：上边的生日，邮箱验证码等
-   替换邮箱/手机号 截取验证码

### 记住我功能

-   简单的可伪造的cookie
-   shiro

### 图形验证码

-   前端返回验证码
-   验证码置空（验证码无效）
-   验证码存在一个万能值
-   验证码可重复利用
-   验证码可爆破
-   简单图形验证码可用[打码平台API](http://www.fateadm.com/)+[burp插件](https:/github.com/f0ng/captcha-killer-modified)批量验证

### 密码修改功能

-   爆破现有密码
-   不检查现有密码
-   未授权访问 修改功能的url 直接修改密码
-   越权修改别人密码

### 对JWT的攻击
https://jwt.io/

#### A. JWT三部分
- HEADER
- PAYLOAD
- VERIFY SIGNATURE

`HEADER`必须写hash算法，如==HS256(hmac sha256，即哈希摘要算法sha256)==
```json
{"alg": "HS256"}
```
其他的就随意了


`PAYLOAD`部分就是base64的json数据


签名部分就是用`HEADER`写的hash算法对`HEADER` 和 `PAYLOAD`计算，这个计算是可以加上`secret`的，当然也可以不加。

```json
HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload),secret)
```


#### B. 攻击面

**1. No secret && Crack secret**

当拿到一个jwt token的时候，去jwt.io解密，
- 尝试将`HEADER`中的alg设置为none：`{"alg": "none"}`，直接伪造`PAYLOAD`
- 不改变`HEADER`中的alg，不填`secret`字段，直接伪造`PAYLOAD`
- 如果这个jwt token时间上还是有效的，上工具爆破secret
`python3 jwt_tool.py -C [JWT_TOKEN] -d /usr/share/wordlists/seclists/Passwords/probable-v2-top12000.txt`

**2. Refresh access_token**

根据实际业务，观察用于获取token的请求包与响应包
是否有明显的:
 - `access_token`(用于访问业务) 
和
 - `refresh_token`(用于刷新访问业务的token)
或者是其他的`xxx_token`(视情况来看)

尝试`refresh_token`是否有越权，可以刷新其他用户的`access_token`

如果有其他类似功能性的token，也是可以去测一测。


**3. Controllable data**

案例是，后端代码会从`HEADER`部分的某个字段中取值
将这个值直接拼接进数据库，造成sql注入

总之是要关注`任何的可控点`以及它可能在`代码`中的`位置`和`作用`，进行测试
